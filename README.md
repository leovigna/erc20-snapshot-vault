# Solidity Starter Project
A smart contract to proportionally split periodical cashflows to a set of ERC20 holders.

## Intro
Many crypto projects have benefited from the use the ERC20 token standard to raise funding and/or to incentivize user behavior such through airdrops or staking programs. 

The most common approach is to set a fixed supply and allocate a certain share of tokens to various budget concerns such as founding team, investors, liquidity mining, legal and marketing. However, this approach is flawed due to its static nature and it often ends up being the case that planned budgeting items are over or under estimated. 

Mintable tokens have an uncapped token supply that can grow depending on certain factors such as a governance vote, staking or other protocol constraints. This removes the static constraint and enables a more dynamic allocation of tokens depending on how different actors interact. One stakeholder however, is often quite adverse to mintable tokens: investors. This is due to the dilution effect that minting creates. In such situations, each percentage point of dilution must be accompanied by equivalent growth in value of the protocol to preserve investor value.

A solution to these conflicting incentives is to have a special set of non-dilutive tokens that protect investor value by cancelling out dilution. For example, a dilution protected investors with 5% of the token supply will always have 5% of the supply regardless if the supply is 100 or 1 million.

A prototype of such a solution was introduced using ERC-721 NFTs to represent the protected shares held by investors but the non-fungibility of these shares makes them impractical for trading. Furthermore, to avoid looping overflow, we use a push-pull architecture where investors must burn their NFTs to claim the newly minted tokens. This means they then forfeit future dilution protection. The solution is therefore incomplete: investors are dilution protected but only up to the point in time where they trade in the dilution protection for the minted tokens.

A new architecture is therefore necessary where:

- The protected dilution protection class is also represented by an ERC20 token
- Investors can claim minted tokens and preserve their future dilution protection.

Also see https://www.notion.so/ERC20-Non-Dilutive-V2-8f74bde5b2b140938d73f731c21c1583

## Contracts
- ERC20Common: The base common token. ERC20Mintable token. Sends X% of minted tokens to a vault for dilution protected investors.
- ERC20Preferred: The preffered vault share token. Represents ownership in the Vault's assets. Note that it might be preferrable to integrate the token logic directly into the vault smart contract.
- PreferredVault: A vault storing dilution protected investor's token. Minted tokens are "pushed" here by ERC20Common and must then be claimed (aka "pulled") individually by each investor. For this first prototype, investors MUST burn their share to claim their share of minted tokens. Burning is required as otherwise, investors could claim tokens twice. This basically improves the original prototype by replacing ERC721 with ERC20.
- PreferredSnapshotVault: Additional improvement upon the preferred vault. Whenever tokens are minted by ERC20Common, the amount is stored by incrementing snapshot id. At the same time a snapshot of ERC20Prefferred holdings is made. This makes it possible to claim the newly minted tokens without burning the ERC20Prefferred token and therefore continue future dilution protection. Make sure to checkout OpenZeppelin's ERC20Snaphotable to see how ERC20 snaphotting is efficiently implemented in Solidity.

## Getting Started

### Installing

Save storage with [pnpm](https://pnpm.js.org/). You can also use regular NPM or Yarn.

```
pnpm install
```

### Directory Structure

```
lib
├── abi # abi output from src/
|
├── ethers # ethers contract abstractions codegenned from abis only (no bytecode)
│
├── solidity # the contracts themselves, in .sol form
│
├── truffle  # truffle contract abstractions codegenned from abis + bytecode
|
└── web3  # web3 contract abstractions codegenned from abis + bytecode
```

### Usage

These smart contracts can be imported as a dependency in various ways described below.

#### Solidity

The solidity smart contracts themselves can simply be imported via the `solidity` directory of `@leovigna/erc20-snaphot-vault`.

```solidity
import "@leovigna/erc20-snaphot-vault/solidity/Example.sol";
```

#### Artifacts

JSON artifacts generated by sol-compiler are available under the abi directory.

```typescript
import ExampleArtifact from '@leovigna/erc20-snaphot-vault/abi/Example.json';
```

#### Ethers

This library ships with `ethers` contract factory abstractions generated by typechain. To use these, make sure you have `ethers` installed as a dependency:

```
pnpm install ethers --save
```

You can then create an ethers contract as follows:

```typescript
import ExampleEthers from '@leovigna/erc20-snaphot-vault/ethers/Example';
const example = ExampleEthers.attach(deployed.address).connect(
    new ethers.providers.JsonRpcProvider('http://localhost:8545'),
);
```

This gives a fully typed (if using TypeScript) version of a ethers contract factory. See the ethers documentation on usage.

#### Truffle

This library ships with `@truffle/contract` abstractions of each of our smart contracts. To use these, make sure you have `@truffle/contract` as a dependency.

```
pnpm install @truffle/contract --save
```

You can then create an truffle contract as follows:

```typescript
import ExampleTruffle from '@leovigna/erc20-snaphot-vault/truffle/Example';
const example = await ExampleTruffle.new();
```

This gives a fully typed (if using TypeScript) version of a truffle contract. See the truffle documentation on usage.

#### Web3

This library ships with `web3-eth-contract` abstractions of each of our smart contracts. To use these, make sure you have `web3` and `web3-eth-contract` as a dependency.

```
pnpm install web3 web3-eth-contract --save
```

You can then create an web3 contract as follows:

```typescript
import ExampleWeb3 from '@leovigna/erc20-snaphot-vault/web3/Example';
const example = ExampleWeb3(web3);
```

This gives a fully typed (if using TypeScript) version of a web3 contract. See the web3 documentation on usage.

### Cloning

To clone this starter repo and add it as an upstream folow below:

```
git clone https://github.com/leovigna/erc20-snaphot-vault.git myproject
cd myproject
git remote set-url origin git@github.com/leovigna/myproject.git
git remote add upstream https://github.com/leovigna/erc20-snaphot-vault.git
git push origin master
git push --all
```

Then to sync any new changes form this repo to the new repo follow these [instructions](https://help.github.com/en/articles/syncing-a-fork).

```
git fetch upstream
git checkout master
git merge upstream/master
```

### Testing

```
npm run test
```

### Codestyle

```
npm run lint
```

## Contributing

To contribute code, feel free to fork this repo.

## License

2021 Leo Vigna
MIT License.
